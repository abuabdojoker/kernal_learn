%-*- coding: UTF-8 -*-
%Embedded_system_1.tex
%嵌入式系统第一次实验报告
\documentclass[hyperref,UTF8]{ctexart}

\usepackage{listings}               %代码高亮宏包
\usepackage{fancyvrb}               %引入Verbatim环境宏包
\usepackage[perpage]{footmisc}      %每页脚注独立宏包
\usepackage{geometry}               %页面大小设置宏包

\geometry{a4paper,left=3cm,right=3cm,bottom=3cm}
\hypersetup{
    bookmarksopen=true,
    bookmarksnumbered=true,
    pdfborder=0 0 0
}

\title{\heiti 嵌入式系统内核与文件系统实验}
\author{\kaishu 戴文谦\\141180014}
\date{}

\begin{document}

\maketitle
\tableofcontents
\section{实验环境介绍}\label{sec:env-intro}

\subsection{硬件环境}\label{subsec:hw-intro}
硬件开发环境即为嵌入式实验系统开发板x210v3。本次实验用到的硬件资源如下：
\begin{itemize}
    \item 核心处理器：S5PV210，主频1GHz
    \item 内存：512MB
    \item RS--232接口(UART2)
    \item RJ45接口(有线以太网DM9000CEP)
    \item 7英寸电容触摸屏\footnote{本实验仅用到其显示功能}
    \item 功能按键(开机/复位)
    \item Flash:4GB nand-Flash
\end{itemize}

\subsection{软件环境}\label{subsec:sw-intro}
软件环境主机端主要有以下配置：
\begin{itemize}
    \item Ubuntu桌面环境（包含minicom工具）
    \item busybox 1.20.2文件系统
    \item linux内核2.6.35/3.0.8版本
    \item 针对ARM的交叉编译工具链2011.08/2016.08版本\footnote{包含以GNU工具：gcc compiler，binutil，C library，C header}
\end{itemize}
在嵌入式开发板x210v3端，厂商预装了底层的bootloader和Android4.0.4系统。

\section{实验原理说明}\label{sec:exp-prin}

\subsection{嵌入式系统基本开发原理}
嵌入式系统实验中，基本开发原理是：在PC上通过交叉编译工具toolchain生成二进制文件并通过嵌入式系统与主机的通信或外置储存载体写入其中后运行。

目标板的基本引导方式如下：上电启动 $\rightarrow$ 加载bootloader并进行相关硬件的初始化 $\rightarrow$ 与主机通信进行配置和传输内核、文件系统等 $\rightarrow$ bootloader根据环境变量引导启动后续系统 $\rightarrow$ 成功加载目标板上的系统内核和文件系统，高级设备驱动 $\rightarrow$ 在目标机系统上运行嵌入式应用程序。

Minicom是linux下的串口通信工具，本实验利用minicom实现主机与嵌入式系统系统之间的通信以及主机对嵌入式系统的控制。运用minicom软件，对minicom进行基本设置后，即可利用基于RS--232串口标准的的UART接口在主机和目标机之间进行初级引导通信。

实际上，串口通信的通信速率很低，按照minicom\footnote{速率为115200bps = 14.0625KB/s}的波特率设置，传输一个5MB左右大小的内核就需要花6分钟以上的时间，效率极低，故在主机与目标机的后续文件传输等通讯中，改用目标机支持的有线以太网通信是必须的。本实验中，主要用到了tftp文件传输传输协议和NFS共享文件服务系统协议。

tftp协议主要用于在目标机bootloader加载完成后的通信中。在bootloader阶段，目标机会默认采用tftp协议并作为客户机\footnote{主机的tftp-server已经配置好}。在此实验中，tftp协议主要用于向开发板内存写入内核和基于ramdisk文件映像的文件系统。

通过主机linux系统架设的NFS服务器\footnote{主机的NFS服务（portmap, NFS）都已配置好}可以方便的将主机的共享文件夹挂载在目标板上，从而在目标板上的linux系统上方便地使用主机上的远程文件。在目标板上的Linux启动后，若内核和文件系统中都支持NFS系统功能，且网络配置与连接正常，NFS服务即可正常使用。

\subsection{内核系统原理}\label{subsec:kern-prin}
Linux内核是后续嵌入式开发的基础，没有刷入开发板的linux内核则无法实现后续的在开发板上运行嵌入式软件的工作。

配置Linux内核所需要的源代码已经提供，本实验中有两个版本可以选择：2.6.35版本和3.0.8版本，不同的内核版本具有不同的功能和底层实现。内核源代码主要包括的内容有：
\begin{itemize}
    \item 体系结构相关的代码\footnote{本机用到arm/s5pv210}
    \item 内核函数实现代码、内核初始化代码
    \item 内存管理代码、文件系统代码、网络与进程通信相关代码
    \item 内核头文件和库文件代码
    \item 驱动程序代码
    \item 配置内核的脚本文件
\end{itemize}

只有源码而不经编译的内核是无法在机器上运行的。编译时，通过make命令读取Makefile，调用交叉编译工具链，得出目标文件后打包成核心和压缩的核心映像文件。嵌入式开发板加载bootloader成为tftp协议的目标机后，即可将在主机中生成的内核映像刷写到开发板中。

为了在内核中实现功能模块的取舍和基本的配置选项、编译方式等参数，通过make命令编译内核前，需要通过依赖于config.in的配置工具\footnote{make menuconfig}来产生或更改内核配置文件.config。配置工具中有多个主要可选分支项：
\begin{itemize}
    \item Genernal setup
    \item System type
    \item Networking Options
    \item Device Drivers
    \item File systems
\end{itemize}
以上分支项将在之后的实验过程涉及时进一步说明。

在内核配置完成后，通过make命令，可以编译内核。在编译内核的过程中，内核顶层的Makefile将读取配置工具产生的.config文件，并根据.config文件中的设置来调用子文件夹中的Makefile以编译相关功能对应的代码。

\subsection{文件系统原理}\label{subsec:fs-prin}
嵌入式开发的文件系统是在嵌入式储存设备上命名、放置、管理文件的系统。

实际上，不同于Windows系统\footnote{Windows系统从改用NT内核开始采用NTFS文件系统，早期使用的是FAT(16)、FAT32}，Linux下的文件系统分为ext系列，NFS，FFS系列等，他们的区别在于组织文件的形式和底层的管理文件方式不同。实验中主要涉及以下几种类别的文件系统:
\begin{enumerate}
    \item ext文件系统：是linux普通磁盘上最常见的文件系统，目前主要有ext2fs，ext3，ext4，与windows的典型不同在于支持快速符号链接，ext3版本开始支持用于恢复文件的日志\label{item:intro-ext}
    \item 网络文件系统NFS：可以通过mount命令将远端的文件系统挂载在本机的\textbackslash mnt文件夹下，从而方便的使用网络上其它计算机的文件
    \item FLASH文件系统：以JFFS2、YAFFS2文件系统为代表，是专门针对闪存设计的文件系统，特点是采用“追加式”文件系统，对FLASH的使用寿命损耗较小。\label{item:intro-flash}
\end{enumerate}

在实验中还有一种特殊的Ramdisk，是将预先制作好的映像载入内存中，用内存的一部分空间来模拟一个与映像内里完全相同的硬盘分区。这类文件系统在组织文件的方式上由对映像格式化的程序来决定\footnote{在系统中会显示为ext/yaffs2等}，但由于对ramdisk的修改本身不会同步到映像，内存断电后又会失去数据，此类Ramdisk在系统关机后只能保留原有映像的内容，故也可将Ramdisk作为一种不同的文件系统。

Linux的根文件系统通常包含以下几个按文件系统规范储存相应文件的文件夹：\footnote{以实际制作出的文件系统为例}

bin\qquad dev\qquad etc\qquad lib\qquad mnt\qquad proc\qquad sbin\qquad

制作根文件系统采用的是Busybox软件。Busybox是一个继承了各种系统基本命令、配置、工具的软件，适用于嵌入式系统。交叉编译完成后，软件能产生一个基于busybox主程序组成的根文件系统，加入基本的库文件、启动文件和设备文件后即可制作成嵌入式开发板上Linux系统的根文件系统。

\section{实验过程与内容}\label{sec:exp-content}

\subsection{嵌入式系统基本开发实践}\label{subsec:basic-exp}
设置开发环境：编译程序用交叉编译工具链为arm-2016.08版。为方便调用编译工具，在终端设置以下环境变量：
\begin{Verbatim}[frame=single]
$ export PATH=/opt/arm-2016.08/bin:$PATH
\end{Verbatim}
此后可在任意路径下直接调用编译器。编写一个简单的C程序1234.c：
\begin{lstlisting}[language=C,flexiblecolumns]
/* 1234.c */
#include <stdio.h>
int main(int argc, char* argv[])
{
    printf("Hello world!!\n");
    return 0;
}
\end{lstlisting}

在同一目录下编译程序1234.out，作为后续尝试在开发板Linux系统上运行的程序，并将其拷贝至主机NFS共享目录\footnote{/srv/nfs4}下待用：
\begin{Verbatim}[frame=single]
$ arm-linux-gcc -o 1234.out 1234.c
$ cp 1234.out /srv/nfs4/1234.out
\end{Verbatim}

为保证主机和从机能够通信且不与实验室其它电脑冲突，设定本机IP地址：
\begin{Verbatim}[frame=single]
$ ifconfig eth0 192.168.208.27
\end{Verbatim}

运行minicom，进行串口的初始化设置：输入Ctrl+A-o，设置通信口为/dev/ttyS0，波特率为115200bps，数据位8位，无奇偶校验，一个停止位。配置完成后选择保存配置并返回minicom主界面。minicom配置后，将从主机引出的串口线接到开发板的UART2接口上，网线接到RJ45接口上，电源线接到供电插孔上，确认无误后才按下开发板的开机键。

上电后，主机和开发板会通过串口通信，minicom主界面上会出现开发板的启动信息。出现“autoboot”字样时通过键盘干预停止加载后续内核工作，进入bootloader的交互模式。作为第一次操作，应该配置bootloader的环境变量，本机按如下设置：
\begin{Verbatim}[frame=single]
x210 # setenv ipaddr 192.168.208.127
x210 # setenv serverip 192.168.208.27
x210 # setenv gatewayip 192.168.208.254
x210 # setenv netmask 255.255.0.0
x210 # setenv ramdisk root=/dev/ram rw initrd=0x40000000,8M
x210 # setenv bootargs console=ttySAC2,115200 $ramdisk
x210 # saveenv
\end{Verbatim}

输入下列命令将位于主机tftp文件夹\footnote{/srv/tftpboot/}下已经编写好的内核和ramdisk文件系统\footnote{由主机root用户提供}刷入开发板的内存中并启动该内核：\label{para:boot-test}
\begin{Verbatim}[frame=single]
x210 # tftp 0x30008000 zImage2.6
x210 # tftp 0x40000000 ramdisk_img.gz
x210 # bootm 0x30008000
\end{Verbatim}

minicom显示大段系统启动过程消息后，出现root用户文件系统中提供的欢迎信息并进入命令行sh，即启动系统成功。接下来配置开发板上运行的Linux系统的网络功能并将主机的NFS共享文件夹挂载到开发板上的Linux系统：
\begin{Verbatim}[frame=single]
# ifconfig eth0 192.168.208.127
# mount 192.168.208.27:/srv/nfs4 /mnt -o nolock,proto=tcp
\end{Verbatim}

配置成功后，输入以下命令：
\begin{Verbatim}[frame=single]
# cd /mnt
# ls
\end{Verbatim}
显示\verb"1234.out"，说明网络配置正确且NFS服务正常运行。

再输入\verb".\1234.out"，显示如下：
\begin{Verbatim}[frame=single]
Hello world!!
\end{Verbatim}
目标板上的Linux系统成功运行主机交叉编译生成的C语言程序。

\subsection{Linux内核编译与配置}\label{subsec:creat-kern}
实验主机上有Linux2.6.35和3.0.8两个内核版本可选，本次试验选择2.6.35版本。为在主机中将源文件交叉编译为arm处理器的内核，需要在终端中设置环境变量：\label{para:set-path}
\begin{Verbatim}[frame=single]
$ export ARCH=arm
\end{Verbatim}

进入内核所在文件夹，首先需要载入适合x210v3开发板的默认配置文件\footnote{手工配置相当繁琐}，再进入配置编译内核的界面：\label{para:kern-init} \footnote{对于3.0.8版本为make x210\_initrd\_defconfig}
\begin{Verbatim}[frame=single]
$ make x210ii_initrd_defconfig
$ make menuconfig
\end{Verbatim}

在图形界面中对以下几个选项进行配置：\label{para:kern-conf}
\begin{enumerate}
    \item Genernal setup：选择内核配置选项和编译方式等
    \begin{enumerate}
        \item Cross-compiler tool prefix：指定交叉编译工具的编译器。此处填入/opt/arm-2011.08\\/bin/arm-linux-\footnote{内核与普通编译的程序不同，只能使用2011.08版本的编译器}
        \item Initial RAM filesystem and RAM disk (initramfs/initrd) support：指定内核是否支持使用ramdisk，内核实验中必须依赖ramdisk，故此处将此项选上。
        \item Initramfs source file(s)：本实验中ramdisk会单独刷入，故应将此项置空。\label{item:ramimg}\footnote{原来有填入ramdisk映像}
        \item Optimize for size：生成体积较小的内核，嵌入式开发中一般选上此项减小内核体积。
        \item Configure standard kernel features (for small systems)：为嵌入式系统设计的选项，可以微调内核的一些功能。嵌入式开发中一般将此项选上，选中后才会出现选择性支持压缩ramdisk镜像的选项。
        \item Support initial ramdisks compressed using gzip：是否支持gzip压缩后的ramdisk映像，本实验选上此项。
    \end{enumerate}
    \item Enable loadable module support：允许不常用的功能以模块化形式放在内核外，需要用到时再加载。嵌入式实验中一般选择此项，可以减少内存占用和内核大小。
    \item System Type：设置处理器架构等相关选项，载入相应的默认配置文件后一般不需要手工调整，本实验不涉及该选项。
    \item Networking support：网络配置选项
    \begin{enumerate}
        \item Networking options：基础网络功能配置，不含wifi，红外等功能的调节选项。
        \begin{enumerate}
            \item TCP/IP networking：使内核支持TCP/IP网络协议\footnote{在因特网和局域网上广泛使用，另一常用协议为bootloader使用的UDP}。不选此项网络功能会受到极大限制，为了配置网络实现NFS功能，此处选上此项。
            \item IP: kernel level autoconfiguration：此功能用于在内核启动阶段就对IP地址自动配置，采用Ramdisk内存映像时，可以在系统启动后手工配置，暂不选上此项。\label{item:ipautoconf}
        \end{enumerate}
    \end{enumerate}
    \item Device Drivers：驱动程序设置
    \begin{enumerate}
        \item Generic Driver Options：驱动程序全局设置
        \begin{enumerate}
            \item Maintain a devtmpfs filesystem to mount at /dev：此项用于产生/dev文件夹下的设备文件。选择此项，内核将在加载阶段就会自动产生设备文件并保留。\footnote{若文件系统下的/dev包含了设备工作所需的设备文件则不需选择此项,但选上此项依然可以加速启动}一般开发中都选上此项。
            \item Automount devtmpfs at /dev, after the kernel mounted the rootfs：此项用于在内核挂载根文件系统后将自动将产生的设备文件挂载到/dev文件夹中，依赖于上一项的选择。一般在选上上一项时也会选上此项。\label{item:devsup}
        \end{enumerate}
        \item Network device support：网络设备驱动支持
        \begin{enumerate}
            \item Ethernet：以太网驱动支持，实际上开发板向外的网路即为局域以太网，此处为了配置网络验证NFS功能选上此项。
        \end{enumerate}
    \end{enumerate}
    \item File systems：与文件系统相关的设置，将在文件系统实验中详细说明。\footnote{见\ref{para:kern-fs-set}}
    \begin{enumerate}
        \item Second extended fs support：Ext2文件格式支持，由于后续刷入的文件系统映像是Ext2格式，此处需要选上。\label{item:ext2set}
        \item Network File Systems：网络文件系统相关设置
        \begin{enumerate}
            \item NFS client support：支持挂载NFS文件系统，为验证NFS功能此处选上此项。\label{item:nfsset}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}

退出配置界面后，提示configuration written to .config，保存设置成功。调用实验主机的八线程CPU\footnote{Core i7 桌面CPU为4核心，利用超线程技术虚拟出8线程}来加快编译内核：
\begin{Verbatim}[frame=single]
$ make -j8
\end{Verbatim}

提示编译成功后，将编译成功的内核zImage找出并复制到tftp文件夹下，再进入minicom刷入编译后的内核和ramdisk，可以成功启动，证明内核制作成功。\footnote{详细操作见\ref{para:boot-test}}

\subsection{创建嵌入式文件系统}\label{subsec:crt-fs}
根文件系统的主要组成来源于交叉编译busybox，设置环境变量\footnote{详细操作见\ref{para:set-path}}后，通过make menuconfig命令进入busybox的编译设置
\begin{itemize}
    \item Busybox Settings
    \begin{enumerate}
        \item Build Options
        \begin{enumerate}
            \item Build BusyBox as a static binary(no shared libs)：对busybox程序执行静态编译。\footnote{若只需要busybox提供的基本操作功能，可选择此项而不加入动态链接库}希望系统能执行交叉编译的文件故不选此项选择加入相应的动态链接库。\footnote{相关操作见\ref{para:dll-set}}
            \item Cross Compiler prefix：交叉编译器设置。由于先前设置了环境变量，可直接填入编译器名称：arm-linux-
        \end{enumerate}
        \item Installation Options ("make install" behavior)
        \begin{itemize}
            \item (./\_install) BusyBox installation prefix：指定BusyBox输出文件系统所在的文件夹，这里取默认值。
        \end{itemize}
    \end{enumerate}
\end{itemize}

配置完成后，输入以下命令，将在{\verb"./_install"}文件夹生成文件系统的雏形：
\begin{Verbatim}[frame=single]
$ make
$ make install
\end{Verbatim}

若在内核中没有配置产生设备文件\footnote{见\ref{para:kern-conf} \ref{item:devsup}}，则还需要在dev目录下建立必要的设备：
\begin{Verbatim}[frame=single]
$ mknod console c 5 1
$ mknod null c 1 3
$ mknod zero c 1 5
\end{Verbatim}

\label{para:dll-set}

进入内核编译选项界面\footnote{详细操作见\ref{para:kern-init}}，对以下几项进行设置：\label{para:kern-fs-set}
\begin{enumerate}
    \item IP: kernel level autoconfiguration\footnote{详细位置见\ref{para:kern-conf} \ref{item:ipautoconf}}，若需要配置NFS作为根文件系统则需要选上此项否则不会出现相关选项。
    \item File systems：
    \begin{enumerate}
        \item Second extended fs support\footnote{介绍见\ref{para:kern-conf} \ref{item:ext2set}}
        \item Ext3 journalling file system support：Ext3文件系统支持
        \item The Extended 4 (ext4) filesystem：Ext4文件系统支持\footnote{见\ref{subsec:fs-prin} \ref{item:intro-ext}}
        \item Miscellaneous filesystems：其他文件系统格式\footnote{嵌入式系统一般存储载体为flash上，故主要关注flash相关文件格式 \ref{subsec:fs-prin} \ref{item:intro-flash}中有介绍}
        \begin{enumerate}
            \item YAFFS2 file system support：YAFFS2文件系统支持，这种文件系统适用于现在常见的NAND flash。如要访问嵌入式系统自带的flash选择此项。\label{item:supyaffs2}
            \item Journalling Flash File System v2 (JFFS2) support：JFFS2文件系统支持，一般用于NOR flash，现在已经比较少见。
        \end{enumerate}
        \item Root file system on NFS\footnote{实际上是位于\ref{para:kern-conf} \ref{item:nfsset}之下的选项} ：选择此项则支持NFS作为根文件系统启动。
    \end{enumerate}
\end{enumerate}

根据需要制作的文件系统选择相应的选项后编译内核。

接下来要补全根文件系统使其能够正常运行：
\begin{itemize}
    \item
{
    建立系统初始化必须的文件和启动脚本：\footnote{省略部分vim内操作提示}
\begin{Verbatim}[frame=single]
$ vim etc/inittab
# /etc/inittab
::sysinit:/etc/init.d/rcS
::askfirst:-/bin/sh
::once:/usr/sbin/telnetd -l /bin/login
::ctrlaltdel:/sbin/reboot
::shutdown:/bin/umount -a -r
$ vim etc/rc
#!/bin/sh
hostname x210
mount -t proc proc /proc
/bin/cat /etc/motd
chmod +x etc/rc
$ vim etc/motd
Welcome to ARM-LINUX SYSTEM!
$ cd etc
$ mkdir init.d
$ cd init.d
$ ln -s ../rc rcS
\end{Verbatim}
}
    \item 建立proc空目录
    \item 建立运行程序所需动态链接库的lib目录，将交叉编译器下的几个库文件ld-2.13.so，libc-2.13.so，libm-2.13.so复制进去并建立符号链接：
\begin{Verbatim}[frame=single]
$ ln -s ld-2.13.so ld-linux.so.3
$ ln -s libc-2.13.so libc.so.6
$ ln -s libm-2.13.so libm.so.6
$ ln -s ld-2.13.so ld-linux-armhf.so.3
\end{Verbatim}
\end{itemize}

对于单独刷入目标机内存的文件系统，需要制作文件系统的映像文件，以制作Ext2文件系统映像为例：\footnote{mke2fs为使用ext2文件系统格式化，改用mkfs.ext3等命令则可使用ext3文件系统与其他文件系统格式化}
\begin{Verbatim}[frame=single]
$ dd if=/dev/zero of=ramdisk_img bs=1k count=8192
$ mke2fs ramdisk_img
$ mount ramdisk_img
$ cp -r /_install/* /mnt/ramdisk
$ umount /mnt/ramdisk
$ gzip ramdisk_img
\end{Verbatim}
将内核和ramdisk刷入开发板即可工作。

将NFS作为根文件系统，则实际上的根文件系统位于Ubuntu主机上的NFS文件夹中，故需要在minicom中更改bootloader对内核的传递参数才能正常启动：
\begin{Verbatim}[frame=single]
$ cp -r /_install/* /srv/nfs4/nfslinux
$ minicom
x210 # setenv rootfs root=/dev/nfs rw nfsroot=192.168.208.27:/srv/nfs4/
nfslinux
x210 # setenv nfsaddrs nfsaddrs=192.168.208.127:192.168.208.27:192.168.
208.254:255.255.0.0
x210 # setenv bootargs console=ttySAC2,115200 $rootfs $nfsaddrs
x210 # saveenv
\end{Verbatim}
只需要刷入内核，启动后开发板会自动载入位于主机上的根文件系统。

还可以选择制作包含于内核中的ramdisk，理论上只需要将先前制作的文件系统打包即可，但实际操作中包含于内核的ramdisk\emph{根目录下没有init}无法启动，故应进行以下操作：
\begin{Verbatim}[frame=single]
$ cd _install
$ ln -s /sbin/init init
$ find ./ -print |cpio -H newc -o |gzip -9 > ~/ramdisk.cpio.gz
\end{Verbatim}

再进入内核配置界面中，将"Initramfs source file(s)"一项设置为{\verb"~/ramdisk.cpio.gz"}\footnote{具体位置见\ref{para:kern-conf} \ref{item:ramimg}}，重新编译即可得到包含文件系统的内核，单独刷入该内核即可正常运行系统。

虽然本实验没有直接制作一个YAFFS2文件系统，但可以对已有的该种文件系统进行探究：嵌入式开发板的flash即采用该种文件系统。无论先前采用哪种根文件系统配置方式，只要内核中配置了对YAFFS2文件系统的支持\footnote{见\ref{para:kern-fs-set} \ref{item:supyaffs2}}并开启了自动产生设备文件选项\footnote{见\ref{para:kern-conf} \ref{item:devsup}}，便可以采取以下操作：
\begin{Verbatim}[frame=single]
# mount /dev/mtdblock2
# mount
# chroot /mnt/mtdblock2
# ls /
\end{Verbatim}

终端上的显示说明mtdblock2设备实际上是一个可读写的，格式为yaffs2的磁盘。同时观察根目录下文件结构可知该磁盘内实际上存放的就是厂商预装的安卓系统。实际上，这种改变根目录的方法在嵌入式系统的应用上相当常见，可以通过精简的ramdisk文件系统启动Linux后，再将格式为yaffs2的flash作为后续运行系统的大型根文件系统。这样做，可以依靠flash的大容量，容纳后续程序的开发，载入内核模块化后的多项可选功能。

\section{实验讨论与小结}

\subsection{部分实验问题讨论}
{\quote{\kaishu *研究NFS作为根文件系统的启动过程。}}

实际上这是探究bootloader引导启动内核和根文件系统的问题，下面就尝试对比分析bootloader环境变量对启动过程的影响：

\begin{enumerate}
\item {开发板自带安卓系统的启动

如按以下方式设置，不跳过bootloader的autoboot阶段可以自动启动安卓系统：
\begin{Verbatim}[frame=single]
x210 # setenv bootargs console=ttySAC2,115200 root=/dev/mtdblock2 rw
rootfstype=yaffs2 init=/linuxrc
\end{Verbatim}
\item ramdisk的启动方式\footnote{默认已做过\ref{subsec:basic-exp}中的设置}

如按以下方式设置，直接输入boot命令而无需指定bootm地址即可启动该种文件系统下的内核：
\begin{Verbatim}[frame=single]
x210 # setenv bootcmd bootm 0x30008000
\end{Verbatim}
}
\item NFS文件系统下的启动方式\footnote{默认已做过\ref{subsec:crt-fs}中的设置}

对比以上两种启动方式bootloader的环境变量，可知bootloader的bootargs，bootcmd参数决定了开发板的启动方式。

NFS文件系统对环境变量的设置等价于下列语句：
\begin{Verbatim}[frame=single]
x210 # setenv bootargs console=ttySAC2,115200 root=/dev/nfs rw
nfsroot=192.168.208.27:/srv/nfs4/nfslinux 192.168.208.127:
192.168.208.27:192.168.208.254:255.255.0.0
\end{Verbatim}

同时，根据设置界面的逻辑可知：还需要选择“内核启动阶段IP自动配置”选项才可能支持NFS文件系统作为根文件系统启动。
\end{enumerate}

通过以上分析，对NFS文件系统的启动概述如下：

将UART2串行接口上的另一端作为主机控制端；将nfs设备文件作为启动后的根目录，可读可写；指定采用nfs文件系统；内核根据bootargs传入的网络参数自动配置好IP参数后，将网络上主机nfs文件夹下的指定目录作为实际上的根目录启动该文件系统。

而bootcmd参数主要决定了bootloader默认启动参数boot执行的命令内容，由于内核还是通过tftp方式传到开发板的内存中，故此项设置为bootm 0x30008000即可进行NFS文件系统的启动。

\subsection{实验小结}
本次实验对嵌入式系统的基本开发原理进行了了解，并为后面的实验打下了基础：实现了可用的内核、文件系统并将其刷写到x210v3开发板中，提供了后续的嵌入式程序运行环境。

通过本次实验实际上了解了以下内容：

通过Ubuntu桌面环境的几次操作，熟悉了不同于Windows系统的Linux系统，掌握了一些基本命令与操作方法。在Linux和bootloader相关基础知识储备下，学会了运用minicom程序分别通过串口和以太网在主机和开发板上进行通信。

利用自动化工具Make和内核源码，交叉编译工具链，根据所需功能编译了适用于嵌入式系统的Linux内核，对内核无用的功能做出了删减或模块化，掌握了编译内核的方法和大量内核配置参数、内核功能的含义。

构建了Linux根文件系统并以传统的Ext格式，nfs网络格式进行实现，探究了bootloader的启动过程和相应传递参数的意义。

初步了解了将ramdisk作为引导文件系统启动开发板Linux后转入flash上YAFFS2文件系统的方法及其对后续开发工作中的意义。

\end{document}
